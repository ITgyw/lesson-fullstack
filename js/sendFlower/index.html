<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>送花</title>
</head>

<body>
    <script>
        // 浏览器 上网代理 ，运行页面的时候，js 的宿主环境 
        // 作用域
        function func() {
            let c = 3; //局部变量

        }
        // 全局变量 
        // 变量名  地址的映射  属于宿主环境的作用域
        // 空间大小 决定了吧？ 整数空间
        // let d; //undefine 没有值  类型未定义 空间起始地址未定义 空间大小未定义
        // var a = 1; //var es5 及以前  js 变量常量声明的关键字
        // let b = 2; //es6 之后提供的 let const 

        // const name = "胡";
        // let age = 21;
        // const hometown = "南昌";
        // const sex = '男';

        // 除了简单数据类型之外的 一切都是对象
        // 对象也叫对象字面量
        /*
        * JS 如果函数名大写 就是 类的构造函数
        */
        // class Flower {
        //     constructor()
        // }

        // Flower既是类也是类的构造函数
        function Flower(type, num) {
            //this 指向构造函数运行时的对象
            console.log(this)
            this.type = type;// this 指向实例化过的对象
            this.num = num;
        }
        // this 构造对象时就指向那个
        const ych = new Flower('油菜花', 1);//当用new 来运行函数的时候内部this指针会指向new创建的对象
        console.log(ych.type);

        const rose = new Flower('玫瑰', 2);
        console.log(rose.type, rose.num);

        const obj = {
            name: '胡',
            age: 19,
            hometown: '鄱阳',
            sex: '男',
            yz: 88,
            isSingle: true,
            gf: null,
            work_status: undefined,
            //参数
            sendFlower(target) {
                // this 属于函数时 会指向对象 obj
                const flowers = new Flower('玫瑰花', 99);
                // console.log(this);

                // console.log(target)
                // 送花代码?
                //target 类型是对象, 对象上有sendFlower方法
                target.reFlower(this, flowers);
            }
        }
        //送花,
        // []数组 {}对象
        // 对象由那两部分组成？ 属性，方法
        const xm = {
            name: '小美',
            age: 18,
            reFlower(sender, flowers) {

                console.log('收到了' + sender.name + '送的'
                    + flowers.num + '朵' + flowers.type);
            }
        };

        // 老乡和小美是室友，
        // 代理人

        const xiaoh = {
            name: '小红',
            hometown: '鄱阳',
            // 接口
            reFlower(sender, flowers) {
                // target.reFlower(obj);
                // if (sender == '胡') {
                //     console.log('胡哥，你是胡哥吗？ 让我们在一起吧');
                // } else {

                // }
                if (sender.yz < 90) {
                    console.log('拒绝')
                } else {
                    console.log('万达走一波');
                    xm.reFlower(sender, flowers);
                }

                // xm.reFlower(sender, flowers);
            }

        }

        obj.sendFlower(xiaoh);
    </script>
</body>

</html>